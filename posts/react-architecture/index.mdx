# 유지보수 가능한 React 애플리케이션 설계 전략
React 애플리케이션에서 뷰와 비즈니스 로직을 분리하는 것은 **유지보수 가능하고 확장 가능하며 테스트가 용이**한 소프트웨어를 구축하기 위한 핵심 원칙이다. 
이 원칙의 중요성은 시간이 지나도 변치 않지만 이를 구현하는 방식은 끊임없이 진화해왔다.

## 소프트웨어 설계 원칙과 React
효과적인 분리 전략을 이야기하기 앞서, 소프트웨어 설계의 근본적인 원칙을 되짚어볼 필요가 있다. 단일 책임 원칙, 높은 응집도, 낮은 결합도는 견고한 아키텍처를 만드는 데 필요한 밑바탕이 된다. 

React의 맥락에서 이 원칙들은 다음과 같이 해석될 수 있다.

### 단일 책임 원칙 (Single Responsibility Principle, SRP)
하나의 컴포넌트는 단 하나의 기능 또는 관심사에만 집중한다. 

예를 들어, 하나의 컴포넌트가 데이터 가져오기, 전역 상태 관리, UI 렌더링을 모두 수행한다면 이는 SRP를 위반하며 코드의 복잡성을 크게 증가시킨다.

### 높은 응집도 (High Cohesion)
서로 밀접하게 관련된 코드는 물리적으로 가깝게 위치시켜야 한다. 

이는 특정 기능을 수정하거나 이해할 때 여러 파일을 찾아다닐 필요 없이 한곳에서 파악할 수 있도록 도우며 코드의 가독성과 유지보수성을 향상시킨다.

### 낮은 결합도 (Low Coupling)
애플리케이션의 한 부분(컴포넌트, 모듈)이 다른 부분에 대해 최소한의 의존성을 가져야 한다.

컴포넌트 간의 결합도가 높으면 한 컴포넌트의 수정이 다른 컴포넌트에 예상치 못한 부작용을 일으킬 수 있으며, 로직의 재사용 또한 어려워진다.

### 원칙 준수의 중요성
세 가지 원칙은 독립적이지 않고 서로에게 영향을 주며 유기적으로 연결되어 있다. 단일 책임 원칙을 준수하여 컴포넌트의 역할을 하나로 제한하면, 자연스럽게 해당 컴포넌트 내부의 코드들은 모두 그 역할과 관련이 깊어지므로 높은 응집도를 달성하게 된다.
이렇게 각자 명확한 역할과 높은 응집도를 가진 컴포넌트들은 서로의 내부 구현에 대해 알 필요가 없어지므로 낮은 결합도로 이어진다.

이 원칙들을 위반한 코드는 당장은 기능할지 몰라도, 시간이 지남에 따라 테스트, 리팩토링, 재사용이 어려워져 결국 개발 속도 저하와 유지보수 비용 증가로 이어진다.

## 상태의 정의 : 모든 상태는 동일하지 않다.
최신 React 아키텍처를 이해할 때에 있어 중요한 점은 모든 상태를 동일하게 취급하지 않는 것이다. 서로 다른 유형의 상태를 구분하지 않고 혼용해서 사용할 시 애플리케이션의 복잡성은 기하급수적으로 증가한다. 

효과적인 아키텍처 설계를 위해서는 상태를 명확한 범주로 나누어 이해해야 한다.

### UI 상태
특정 컴포넌트의 표현과 직접적으로 관련된 일시적인 상태이다. 이 상태는 다른 컴포넌트와 공유되지 않으며, 해당 컴포넌트 내에서만 유효하다.
- 예시: 드롭다운 메뉴의 열림 여부(`isDropdownOpen`), 입력 필드의 현재 값, 토글 버튼의 활성화 상태
- 관리 도구: 이 상태는 일반적으로 `useState`를 사용하여 컴포넌트 내에서 지역적으로 관리된다.

### 클라이언트 상태
클라이언트에서 생성되고 관리되며, UI의 여러 부분에 걸쳐 영향을 미치는 전역적인 상태이다. `prop drilling`을 방지하고 애플리케이션 전반에 걸쳐 일관성을 유지하기 위해 사용된다.
- 예시: 다크/라이트 모드 테마 설정, 사용자 인증 상태, 장바구니 내용물
- 관리 도구: React Context, Zustand, Redux, Recoil과 같은 전역 상태 관리 라이브러리를 사용해 관리한다.

### 서버 상태
원격 서버가 소유하고 관리하는 데이터의 클라이언트 측 캐시이다. 
이 상태는 다음과 같은 특징을 가진다.
- 비동기적으로 가져온다.
- 다른 사용자와 공유될 수 있어 언제든지 변경될 수 있다.
- 시간이 지나면 '오래된(stale)' 상태가 되어 최신 데이터로 동기화가 필요하다.
- 예시: 사용자 프로필, 게시물 목록, 제품 데이터 등
- 관리 도구: TanStack Query나 SWR 같은 데이터 페칭 라이브러리를 사용해 관리한다. 이 도구는 캐싱, 로딩 및 에러 상태 처리, 데이터 재검증, 요청 중복 제거 등을 자동화한다.

###  URL 상태
브라우저의 URL에 저장되어 관리되는 상태이다. 사용자가 페이지를 새로고침하거나 링크를 다른 사람에게 공유해도 상태가 그대로 유지된다.
- 예시: 데이터 테이블의 필터링 및 정렬 옵션, 현재 페이지 번호, 활성화된 탭 정보
- 관리 도구: `react-router-dom`의 `useSearchParams` 훅이나 `Next.js`의 라우터 기능을 사용하여 관리한다.

### 상태 분류의 중요성
현대 React 애플리케이션의 복잡성은 대부분 상태를 잘못 다루는 것에서 비롯된다. 특히, 근본적으로 다른 성질을 가진 서버 상태를 클라이언트 상태처럼 취급하려는 것이 주된 원인이다. 클라이언트 상태의 데이터 소유권은 클라이언트에 있지만, 서버 상태의 소유권은 원격 서버에 있다.

서버 상태를 클라이언트 상태 관리 도구로 관리하려 할 때, 우리는 캐싱, 로딩/에러 상태 분기, 데이터 재검증, 낙관적 업데이트 로직 등을 매번 수동으로 재구현해야 한다. 이 수동 구현 과정이야말로 엄청난 양의 보일러플레이트 코드, 복잡한 `useEffect` 의존성 배열, 그리고 데이터 페칭의 구현 세부 사항에 강하게 결합된 컴포넌트를 양산하는 주된 원인이다.

따라서 올바른 상태 분류는 효과적인 관심사 분리의 전제 조건이다. 각 상태는 고유한 생명주기와 데이터 소유권을 가지므로, 그 특성에 맞는 관리 전략을 사용해야 한다. 이 구분을 무시하는 것은 결국 복잡성을 높이고 유지보수성을 악화시키는 기술적 부채로 이어질 뿐이다.

## 유지보수성과 확장을 위한 기반 아키텍처 설계
견고한 아키텍처를 설계하는 것은 잘 정리된 집과 같다. 잘 설계된 구조는 개발자가 필요한 것을 쉽게 찾고, 새로운 기능을 안전하게 추가할 수 있고, 시간이 지나도 안정성을 유지할 수 있도록 돕는다. 

React 프로젝트의 폴더 구조를 설계하는 데에는 크게 두 가지 접근 방식이 있으며, 각각의 선택은 프로젝트의 규모와 복잡성에 따라 장단점을 가진다.

### 유형 기반 (Type-Based) 구조
파일의 기술적 유형에 따라 폴더를 구성하는 방식이다. 이 구조는 작은 프로젝트나 프로토타입 단계에서 효과적이며, 인지적 부하가 적고 단순하여 새로운 팀원도 쉽게 파일을 찾을 수 있다는 장점이 있다.
```jsx
src/
├── components/
│   ├── Button.tsx
│   ├── UserProfile.tsx
│   └── ProductList.tsx
├── hooks/
│   ├── useUser.ts
│   └── useProducts.ts
└── services/
    ├── userService.ts
    └── productsService.ts
```

하지만 유형 기반 구조는 프로젝트가 성장함에 따라 명확한 한계를 보인다. '사용자 프로필' 기능을 하나 수정하기 위해 개발자는 `components/`, `hooks/`, `services/`, `store/` 폴더를 계속해서 오가야 한다. 이는 관련 코드가 물리적으로 분산되어 코드의 응집도 원칙을 위반하며, 변경의 영향 범위를 파악하기 어렵게 만들어 유지보수를 어렵게한다.

### 기능 주도 (Feature-Driven) 구조
비즈니스 도메인 또는 기능 단위로 코드를 그룹화하는 방식이다. 이 구조는 중대형 애플리케이션에서 효과적이며, 핵심적인 장점은 **높은 응집도**이다.
```jsx
src/
└── features/
    ├── auth/
    │   ├── components/
    │   └── hooks/
    ├── products/
    │   ├── components/
    │   │   ├── ProductList.tsx
    │   │   └── ProductCard.tsx
    │   ├── hooks/
    │   │   └── useProductsData.ts
    │   ├── services/
    │   └── index.ts
    └── user/
        ├── components/
        │   └── UserProfile.tsx
        ├── hooks/
        └── services/
```

인증(auth) 기능과 관련된 모든 파일이 `features/auth/` 폴더 내에 함께 위치하므로, 특정 기능을 수정하거나 제거할 때 여러 폴더를 헤맬 필요 없이 해당 기능 폴더 내에서만 작업하면 되므로 유지보수성이 크게 향상된다.

프로젝트의 폴더 구조는 정적인 선택이 아니라 **진화**해야 한다. 대부분의 프로젝트는 유형 기반 구조의 단순함으로 시작할 수 있다. 하지만 유형 기반 구조를 탐색하는 비용이 응집력 있는 기능 주도 구조로 리팩토링하는 비용을 초과하는 시점을 인식해야 한다. 이는 단순한 스타일 선호가 아닌, 프로젝트의 지속 가능성을 위한 전략적 결정이다.

#### 기능 슬라이스(Feature Slice)의 구조
기능 주도 구조의 핵심은 각 기능 폴더, 즉 '기능 슬라이스'의 내부 구조에 있다. `features/products/`와 같은 폴더는 그 자체로 하나의 작은 애플리케이션처럼 구성되며, 각 하위 디렉터리는 명확한 책임을 가진다.
- `components/`: 해당 기능에만 특화된 UI 컴포넌트
    - ex) `ProductCard.tsx`, `ProductList.tsx`
- `hooks/`: 기능의 핵심 비즈니스 로직을 담고 있는 커스텀 훅
	- ex) `useProductsData.ts`, `useProductFilters.ts`
- `services/` 또는 `api/`: 데이터 소스와의 통신에 대한 모든 세부 사항을 캡슐화하는 데이터 계층
- `store/` 또는 `state/`: 해당 기능에 특화된 상태 관리 로직
- `types/`: 해당 기능에서 사용되는 타입 정의
- `index.ts`: 해당 기능의 공개 API(Public API), 기능 외부에서 접근할 수 있는 컴포넌트, 훅, 타입만을 `export` 하여 다른 기능이 내부 구현에 직접 의존하는 것을 방지하고 결합도를 낮춘다.

#### 공용 코드의 관리: app, shared, lib
모든 코드가 특정 기능에 속하는 것은 아니다. 애플리케이션 전반에서 사용되거나, 여러 기능에 걸쳐 재사용되는 코드를 위한 공간이 필요하다.
- `app/` 또는 `core/`: 애플리케이션의 진입점과 관련된 최상위 설정을 담당한다. 라우팅 구조 정의, 전역 레이아웃 컴포넌트, 전역 프로바이더 설정(ex. `QueryClientProvider`,  `ThemeProvider`), 최상위 스타일 시트 등이 여기에 위치한다. 
- `shared/`: 특정 도메인에 종속되지 않고, 애플리케이션 전반에서 재사용 가능한 코드를 보관한다.
    - `shared/components/`: 비즈니스 로직이 없는 순수 UI 컴포넌트
	    - ex) Button, Modal, Input
	    - 공용 UI 컴포넌트를 더 체계적으로 관리하기 위해 아토믹 디자인 방법론을 적용해볼 수 있다.
    - `shared/hooks/`: 일반적인 로직을 캡슐화한 훅
	    - ex) `useLocalStorage`, `useWindowSize`
    - `shared/utils/`: 순수 함수로 이루어진 유틸리티 모음
	    - `formatDate`, `validationRules`
- `lib/`: 외부 라이브러리 설정을 캡슐화하거나, 프로젝트 전반의 설정을 관리한다. 
	- 외부 의존성과 관련된 설정을 비즈니스 로직과 분리하여 관리의 용이성을 높인다.
	- ex) `axios` 인스턴스에 인터셉터를 추가하는 설정 코드, `dayjs` 플러그인 설정

## 로직 캡슐화를 위한 핵심 패턴
로직과 뷰를 분리하는 접근 방식은 React Hooks의 도입과 함께 변화했다. 
### 커스텀 훅: 선언적 로직 캡슐화
커스텀 훅(Custom Hook)은 현대 React에서 비즈니스 로직을 컴포넌트로부터 추출하고 캡슐화하는 가장 대표적이고 강력한 메커니즘이다. 커스텀 훅은 단순히 코드를 다른 파일로 옮기는 것을 넘어, 컴포넌트의 의도를 선언적으로 만들어주는 역할을 한다.

잘 설계된 커스텀 훅은 다음과 같은 유형의 로직을 캡슐화할 수 있다.
- **상태 관리 로직**: `useCounter`, `useToggle`과 같이 특정 상태와 그 상태를 변경하는 함수들을 함께 묶어 재사용 가능한 단위로 만든다.
- **사이드 이펙트 관리:** API 호출, 웹소켓 구독, 타이머 설정 등 비동기 작업이나 외부 시스템과의 상호작용을 관리한다.
- **복잡한 폼 상태 관리**: 입력 값, 유효성 검사, 제출 상태 등을 관리하는 `useForm`과 같은 훅을 만들어 폼 로직을 UI로부터 완전히 분리할 수 있다.

예를 들어, `UserProfile` 컴포넌트가 사용자 데이터를 직접 fetch하는 대신 `useUserData`라는 커스텀 훅을 사용한다고 가정해본다.
```tsx
// src/features/users/hooks/useUserData.ts
import { useState, useEffect } from 'react';
import { userService } from '../services/userService';

export function useUserData(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    setIsLoading(true);
    userService.fetchUser(userId)
     .then(setUser)
     .catch(setError)
     .finally(() => setIsLoading(false));
  }, [userId]);

  return { user, isLoading, error };
}

// src/features/users/components/UserProfile.tsx
import React from 'react';
import { useUserData } from '../hooks/useUserData';

export function UserProfile({ userId }: { userId: string }) {
  const { user, isLoading, error } = useUserData(userId);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return null;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}
```
`UserProfile` 컴포넌트는 더 이상 데이터 로딩의 '방법'에 대해 알 필요가 없다. 단지 `useUserData` 훅을 호출하여 필요한 데이터(`user`), 로딩 상태(`isLoading`), 에러 상태(`error`)를 선언적으로 요청할 뿐이다.
모든 비동기 로직과 상태 관리는 `useUserData` 훅 내부에 캡슐화되어, `UserProfile`은 UI 렌더링에만 집중할 수 있게 된다.

다만 위 예제는 `useEffect`를 사용한 기본적인 데이터 페칭 로직이며, 여전히 로딩/에러 상태의 수동 관리, 캐싱 부재와 같은 한계를 가진다. 이러한 서버 상태와 관련된 문제들은 이어지는 파트에서 다룰 전용 라이브러리를 통해 더욱 개선될 수 있다.

### 서비스 계층 : 견고한 데이터 추상화
위 예제에서 `useUserData` 훅은 직접 `fetch`나 `axios`를 호출하지 않고, `userService.fetchUser`라는 함수를 호출했다. 서비스 계층(Service Layer)의 개념으로 서비스 계층은 애플리케이션에서 데이터 소스와의 통신을 전담하는 유일한 부분이어야 한다.

서비스 계층의 책임은 다음과 같다.
- **API 호출**: 실제 HTTP 요청(예: GET, POST)을 보내고 응답을 받는다.
- **데이터 변환**: API로부터 받은 데이터를 애플리케이션의 도메인 모델(타입, 인터페이스)에 맞게 가공하고 정제한다.
- **에러 처리 정규화**: 다양한 형태의 HTTP 에러를 일관된 형식의 에러 객체로 변환하여 상위 계층(커스텀 훅)에 전달한다.
```tsx
// src/features/users/services/userService.ts
interface UserApiResponse {
  id: number;
  name: string;
  email_address: string;
}

interface User {
  id: number;
  name: string;
  email: string;
}

async function fetchUser(userId: string): Promise<User> {
  try {
    const { data } = await apiClient.get<UserApiResponse>(`/users/${userId}`);
    // API 응답(snake_case)을 도메인 모델(camelCase)로 변환
    return {
      id: data.id,
      name: data.name,
      email: data.email_address,
    };
  } catch (error) {
    // 에러를 정규화하여 throw
    throw new Error('Failed to fetch user data.');
  }
}

export const userService = {
  fetchUser,
};
```
이러한 구조는 매우 중요한 경계를 형성한다. 커스텀 훅은 서비스 계층의 함수를 호출하지만, API 엔드포인트의 주소나 데이터의 세부적인 형태에 대해서는 알지 못한다. 이러한 구조는 다음과 같은 장점을 가진다.
1. **독립적 테스트**: 서비스 계층은 `apiClient`를 모킹하여 독립적으로 단위 테스트가 가능하다.
2. **교체 용이성**: 데이터 페칭 라이브러리를 `axios`에서 `fetch`로, 또는 REST API에서 GraphQL로 변경해야 할 때, 오직 서비스 계층만 수정하면 된다. 커스텀 훅이나 컴포넌트는 영향을 받지 않는다.

### 과거 패턴의 진화: 컨테이너/프레젠테이셔널 패턴
과거에 훅이 없던 시절에는 컨테이너/프레젠테이셔널(Container/Presentational) 패턴이 로직과 뷰를 분리하는 표준적인 방법이었다. 컨테이너 컴포넌트가 상태 소유, 데이터 페칭 등의 로직을 처리하고, 프레젠테이셔널 컴포넌트는 props를 통해 데이터를 받아 화면을 그리는 역할만 수행했다.

이 패턴은 로직과 뷰를 분리한다는 정신을 훌륭하게 구현했지만, 커스텀 훅의 등장으로 컨테이너 컴포넌트가 수행하던 거의 모든 역할은 이제 커스텀 훅으로 대체되었다.

이 변화는 단순히 두 개의 파일을 하나로 합친 것 이상의 의미를 갖는 패러다임 전환이다. 과거의 컨테이너/프레젠테이셔널 패턴이 컴포넌트로 다른 컴포넌트를 감싸는 조합 모델이었다면, 커스텀 훅을 사용하는 패턴은 로직을 훅 내부에 숨기고 정의된 인터페이스를 통해 상호작용하는 캡슐화 모델이다.

캡슐화 모델이 더 우월한 이유는 다음과 같다.
- **보일러플레이트 감소**: 컨테이너 컴포넌트 파일 전체와 불필요한 props 전달 과정이 제거된다.
- **향상된 재사용성**: 훅은 컨테이너 컴포넌트보다 훨씬 세분화된 재사용이 가능하다. 여러 개의 작은 훅들을 조합하여 복잡한 동작을 만드는 것은 컨테이너 컴포넌트로는 구현하기 어렵다.
- **단순화된 테스트**: 훅을 격리하여 테스트하는 것이 자식 컴포넌트를 렌더링하는 컨테이너 컴포넌트를 테스트하는 것보다 훨씬 간단하고 명확하다.

결론적으로, 커스텀 훅과 서비스 계층을 이용한 패턴은 컨테이너/프레젠테이셔널 패턴의 '로직과 뷰의 분리'라는 정신은 계승하되, 
캡슐화를 통해 더 효율적이고 재사용 가능한 코드를 작성할 수 있게 한다. 현대의 React 개발에서 이러한 패턴을 이해하고 적용하는 것은 견고하고 유지보수하기 쉬운 애플리케이션을 구축하는 데 필수적이다.

## 진정한 분리를 위한 상태 관리 마스터하기
클라이언트 상태와 서버 상태를 구분하고, 각 작업에 적합한 도구를 사용하는 것은 매우 중요하다. 이 개념을 이해하고 적용하는 것이 현대 React 애플리케이션 아키텍처의 성패를 가르게 된다.
### 클라이언트 상태 관리: 상황에 맞는 도구 선택
클라이언트 상태는 애플리케이션 내부에서 발생하고 관리되는 데이터를 의미한다. 이를 관리하기 위한 도구는 다양하며, 상태의 범위와 복잡성에 따라 적절한 것을 선택해야 한다.
- **지역 상태 (useState, useReducer)**: 상태가 단일 컴포넌트나 아주 가까운 컴포넌트 트리 내에서만 필요할 때 사용한다. 가장 간단하고 직관적인 방법이며, 불필요한 전역 상태 오염을 방지한다.
- **Context API**: 애플리케이션 전반에 걸쳐 필요하지만 자주 변경되지 않는 데이터를 공유할 때 유용하다.
	- ex) 테마, 사용자 인증 정보 
	- `Context`의 단점은 `Context` 값이 변경될 때 해당 값을 구독하는 모든 컴포넌트가 리렌더링된다는 점이다. 따라서 자주 업데이트되는 상태에 사용하면 성능 문제를 야기할 수 있으므로, 상태를 여러 개의 작은 Context로 분리하는 등의 최적화 전략이 필요하다.
- **전역 스토어 (Zustand, Redux Toolkit)**: 복잡하고, 빈번하게 변경되며, 애플리케이션의 여러 부분에서 공유되는 클라이언트 상태를 관리하기 위한 솔루션이다.
    - Zustand: 단순함과 최소한의 보일러플레이트를 추구하며, 훅 기반 API로 React와 자연스럽게 통합
    - `Redux Toolkit`: 예측 가능한 상태 전환, 강력한 미들웨어 생태계, `Redux DevTools`를 통한 타임 트래블 디버깅 등 대규모 애플리케이션의 상태를 일관되게 관리 가능

### 서버 상태 혁명: useEffect를 넘어서
서버 상태 관리는 한 가지 선언으로 시작해야 한다. 
- `useEffect`는 데이터 페칭 도구가 아니다.

`useEffect`를 사용하여 데이터를 가져오는 것은 수많은 문제를 야기한다.
- **경쟁 상태(Race Condition)**: 사용자가 빠르게 여러 요청을 트리거할 때, 응답이 순서대로 도착하지 않아 오래된 데이터가 최신 데이터를 덮어쓰는 문제가 발생할 수 있다.
- **캐싱 부재**: 컴포넌트가 마운트될 때마다 동일한 데이터를 불필요하게 다시 요청한다.
- **재검증 부재**: 다른 탭으로 이동했다가 돌아오거나, 네트워크가 재연결되었을 때 데이터가 자동으로 갱신되지 않는다.
- **수동 상태 관리**: 로딩, 에러, 성공 상태를 매번 `useState`로 직접 관리해야 하며, 이는 컴포넌트를 비대하고 복잡하게 만든다.

이러한 문제들을 해결하기 위해 `TanStack Query`, `SWR`과 같은 서버 상태 라이브러리가 등장했다.

### TanStack Query (구 React Query)
`TanStack Query`는 서버 상태 관리에 필요한 거의 모든 기능을 선언적인 방식으로 제공한다.
- **useQuery**: 데이터 조회(GET)를 담당하며 `queryKey`를 기반으로 데이터를 캐싱하고, 로딩/에러 상태 자동 관리, 데이터 자동 재검증 등을 수행한다.
- **useMutation**: 데이터 생성(POST), 수정(PUT/PATCH), 삭제(DELETE)를 담당한다.
- **쿼리 무효화 (Query Invalidation)**: `useMutation` 성공 후, 관련된 `useQuery` 데이터를 '오래됨(stale)'으로 표시하여 자동으로 다시 가져오게 만드는 메커니즘이다.
	- 예를 들어, 새로운 게시물을 성공적으로 작성했다면, 게시물 목록을 무효화하여 화면을 최신 상태로 갱신할 수 있다.
- **낙관적 업데이트 (Optimistic Updates)**: 서버 응답을 기다리지 않고 UI를 즉시 업데이트하여 사용자 경험을 극대화하는 강력한 패턴이다. 만약 서버 요청이 실패하면, 이전 상태로 롤백한다.

> 새로운 todo를 추가하는 낙관적 업데이트 예시
```tsx
const queryClient = useQueryClient();

const { mutate } = useMutation({
  mutationFn: updateTodo,
  // 뮤테이션이 시작될 때 실행
  onMutate: async (newTodo) => {
    // 진행 중인 refetch를 취소하여 덮어쓰기 방지
    await queryClient.cancelQueries({ queryKey: ['todos'] });
    // 이전 상태 스냅샷
    const previousTodos = queryClient.getQueryData(['todos']);
    // 새로운 값으로 낙관적 업데이트
    queryClient.setQueryData(['todos'], (old) => [...(old || []), newTodo]);
    // 롤백을 위해 이전 상태가 담긴 context 반환
    return { previousTodos };
  },
  // 에러 발생 시 onMutate에서 반환된 context를 사용하여 롤백
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos);
  },
  // 성공 또는 실패 후 항상 데이터를 재검증하여 서버와 클라이언트 상태를 일치시킴
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  },
});
```

### 하이브리드 아키텍처: 두 세계의 장점 결합
현대적인 React 애플리케이션의 이상적인 상태 관리 아키텍처는 하이브리드 모델이다.
- Redux/Zustand: 사용자 세션, UI 테마와 같이 순수한 클라이언트 상태를 관리한다.
- TanStack Query/SWR: 사용자 프로필, 제품 목록 등 모든 서버 상태의 조회 및 변경을 관리한다.

이 하이브리드 모델은 각 도구를 본래 목적에 맞게 사용하여, 관심사를 명확히 분리하고, 보일러플레이트를 줄이며, 성능과 유지보수성을 모두 극대화하는 최적의 방법이다.

서버 상태 라이브러리의 채택은 훅 도입 이후 React 생태계에서 가장 중요한 아키텍처적 변화이다. 이는 프론트엔드를 원격 데이터 소스와 동기화되는 정교한 캐싱 계층으로 바라보게 한다. 

개발자의 초점은 '어떻게 데이터를 가져올 것인가'를 다루는 명령형 코드(`dispatch(fetchPosts())`)에서, '어떤 데이터가 필요한가'를 기술하는 선언형 코드(`useQuery(['posts'], fetchPosts)`)로 이동한다.
이 패러다임 전환은 데이터 중심 애플리케이션을 구축하는 방식을 근본적으로 바꾸어 놓았다.

## React 아키텍처의 진화: 헤드리스 컴포넌트와 서버 컴포넌트
이 파트에서는 관심사 분리를 한 단계 발전시키는 패턴과 미래 지향적 개념을 소개한다. 이러한 개념들은 React 생태계가 나아갈 방향을 제시하며, 아키텍처에 대한 더 깊은 통찰력을 제공한다.
### 헤드리스 컴포넌트 (Headless Components)
헤드리스 UI 패턴은 기능적 로직과 시각적 표현의 분리를 극대화하는 접근 방식이다.
헤드리스 컴포넌트(주로 커스텀 훅으로 구현됨)는 상태 관리, 상호작용 로직, 접근성(ARIA 속성, 키보드 네비게이션 등)을 온전히 책임지지만, UI는 전혀 렌더링하지 않는다. 대신 렌더링에 필요한 상태와 함수들을 반환하여, 개발자가 마크업과 스타일링을 완벽하게 제어할 수 있도록 한다.

예를 들어, 헤드리스 드롭다운 훅은 `isOpen` 상태, `toggle` 함수, 선택된 항목(`selectedItem`), 그리고 각 옵션에 적용해야 할 `props` 등을 반환한다. 개발자는 이를 받아 원하는 HTML 태그와 CSS 스타일을 적용하여 완전히 커스텀된 드롭다운을 만들 수 있다. 

이 패턴은 다음과 같은 장점을 가진다.
- **재사용성과 유연성 극대화**: 순수한 로직만 분리되어 있어 어떠한 디자인 시스템에도 쉽게 통합할 수 있다.
- **뛰어난 접근성**: 복잡한 접근성 구현을 추상화하여 제공하므로 개발자는 비즈니스 로직에 더 집중할 수 있다.

대표적인 라이브러리는 다음과 같다:
- Radix UI: 접근성이 뛰어난 저수준(low-level) UI 프리미티브를 제공하며, 개발자가 자신만의 디자인 시스템을 구축하도록 돕는다. 
- Headless UI: Tailwind CSS 개발팀이 만든 라이브러리로, 완전히 스타일되지 않고 접근성을 갖춘 UI 컴포넌트를 제공한다.

헤드리스 컴포넌트는 재사용 가능하고 유연하며 접근성이 뛰어난 디자인 시스템을 구축하는 현대적인 표준 방식으로 자리 잡고 있다.

### React 서버 컴포넌트 (RSC)
React 서버 컴포넌트는 React 아키텍처에 근본적인 변화를 가져온 개념이다. Next.js의 App Router를 통해 대중화되었으며, 컴포넌트 실행과 데이터 페칭의 주체를 클라이언트에서 서버로 이동시켰다.

RSC의 핵심 이점은 클라이언트로 보내는 **자바스크립트 번들 사이즈를 줄이고**, 데이터 소스와 가까운 서버에서 데이터 페칭을 완료함으로써 초기 로딩 성능을 극대화하는 데 있다. 

RSC는 서버 환경에서 직접 `async/await`를 사용하여 데이터베이스 쿼리나 API 호출을 수행할 수 있다. 렌더링된 결과가 브라우저로 전송되기 전에 데이터 페칭이 완료되므로, 클라이언트 측에서 로딩 상태를 관리할 필요가 없어진다.

이는 클라이언트 측 비즈니스 로직의 범위에 대한 관점을 변화시킨다. 상호작용이 거의 필요 없는 초기 데이터 로드의 경우, 데이터 페칭 로직은 더 이상 클라이언트의 관심사가 아니게 된다. 이로 인해 많은 경우에 TanStack Query와 같은 클라이언트 측 서버 상태 라이브러리의 필요성이 줄어들 수 있다.

하지만 RSC가 모든 것을 대체하는 것은 아니며, 현대적인 애플리케이션은 하이브리드 모델을 채택한다.
Next.js App Router에서는 모든 컴포넌트가 기본적으로 서버 컴포넌트이며, 필요한 경우에만 클라이언트 컴포넌트로 전환해 사용한다.
- 서버 컴포넌트 (기본값): 초기 페이지 로드, 정적 콘텐츠 렌더링, 서버 데이터 직접 접근을 담당하여 클라이언트의 부담을 줄인다.
- 클라이언트 컴포넌트 (`'use client'` 지시어 사용): 사용자의 상호작용(클릭, 입력 등), 상태 관리, 브라우저 API 접근이 필요한 부분에 사용된다. 검색, 필터링, 무한 스크롤 등 동적 데이터 페칭은 여전히 클라이언트 컴포넌트에서 TanStack Query와 같은 라이브러리를 통해 처리하는 것이 효율적이다.

## 결론
소프트웨어 설계의 기본 원칙에서 시작하여 상태의 유형을 분류하고, 로직을 캡슐화하는 최신 패턴을 거쳐 React 아키텍처의 미래까지 알아보았다. 이 글에서 제시된 원칙과 패턴들은 단순히 기술을 나열하는 것이 아니라, 개발자가 더 나은 질문을 던지도록 돕기 위한 것이다.

이제 우리는 "어떤 상태 관리 라이브러리가 최고인가?"가 아니라 "지금 내가 다루고 있는 상태는 어떤 종류이며, 이 상태의 특성에 가장 적합한 도구와 패턴은 무엇인가?"라고 물어야 한다.

이러한 깊이 있는 이해를 바탕으로 내리는 기술적 결정들이 모여, 변화에 유연하게 대응하고 시간이 지나도 그 가치를 유지하는 견고한 애플리케이션을 만들어낼 것이다.
